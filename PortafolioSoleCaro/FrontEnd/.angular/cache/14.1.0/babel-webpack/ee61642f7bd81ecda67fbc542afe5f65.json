{"ast":null,"code":"import { EventEmitter, Component, ElementRef, Inject, Output, Input, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { timer } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction CircleProgressComponent__svg_svg_0__svg_linearGradient_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"linearGradient\");\n    ɵngcc0.ɵɵelement(1, \"stop\", 5)(2, \"stop\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"id\", ctx_r1.svg.outerLinearGradient.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"stop-color\", ctx_r1.svg.outerLinearGradient.colorStop1)(\"stop-opacity\", 1);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"stop-color\", ctx_r1.svg.outerLinearGradient.colorStop2)(\"stop-opacity\", 1);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_radialGradient_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"radialGradient\");\n    ɵngcc0.ɵɵelement(1, \"stop\", 5)(2, \"stop\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"id\", ctx_r2.svg.radialGradient.id);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"stop-color\", ctx_r2.svg.radialGradient.colorStop1)(\"stop-opacity\", 1);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"stop-color\", ctx_r2.svg.radialGradient.colorStop2)(\"stop-opacity\", 1);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_ng_container_4__svg_circle_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"circle\");\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵattribute(\"cx\", ctx_r8.svg.backgroundCircle.cx)(\"cy\", ctx_r8.svg.backgroundCircle.cy)(\"r\", ctx_r8.svg.backgroundCircle.r)(\"fill\", ctx_r8.svg.backgroundCircle.fill)(\"fill-opacity\", ctx_r8.svg.backgroundCircle.fillOpacity)(\"stroke\", ctx_r8.svg.backgroundCircle.stroke)(\"stroke-width\", ctx_r8.svg.backgroundCircle.strokeWidth);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_ng_container_4__svg_circle_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"circle\");\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵattributeInterpolate1(\"fill\", \"url(#\", ctx_r9.svg.radialGradient.id, \")\");\n    ɵngcc0.ɵɵattribute(\"cx\", ctx_r9.svg.backgroundCircle.cx)(\"cy\", ctx_r9.svg.backgroundCircle.cy)(\"r\", ctx_r9.svg.backgroundCircle.r)(\"fill-opacity\", ctx_r9.svg.backgroundCircle.fillOpacity)(\"stroke\", ctx_r9.svg.backgroundCircle.stroke)(\"stroke-width\", ctx_r9.svg.backgroundCircle.strokeWidth);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, CircleProgressComponent__svg_svg_0__svg_ng_container_4__svg_circle_1_Template, 1, 7, \"circle\", 2);\n    ɵngcc0.ɵɵtemplate(2, CircleProgressComponent__svg_svg_0__svg_ng_container_4__svg_circle_2_Template, 1, 7, \"circle\", 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r3.options.backgroundGradient);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r3.options.backgroundGradient);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_circle_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"circle\");\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"cx\", ctx_r4.svg.circle.cx)(\"cy\", ctx_r4.svg.circle.cy)(\"r\", ctx_r4.svg.circle.r)(\"fill\", ctx_r4.svg.circle.fill)(\"stroke\", ctx_r4.svg.circle.stroke)(\"stroke-width\", ctx_r4.svg.circle.strokeWidth);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_ng_container_6__svg_path_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"path\");\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵattribute(\"d\", ctx_r10.svg.path.d)(\"stroke\", ctx_r10.svg.path.stroke)(\"stroke-width\", ctx_r10.svg.path.strokeWidth)(\"stroke-linecap\", ctx_r10.svg.path.strokeLinecap)(\"fill\", ctx_r10.svg.path.fill);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_ng_container_6__svg_path_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"path\");\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵattributeInterpolate1(\"stroke\", \"url(#\", ctx_r11.svg.outerLinearGradient.id, \")\");\n    ɵngcc0.ɵɵattribute(\"d\", ctx_r11.svg.path.d)(\"stroke-width\", ctx_r11.svg.path.strokeWidth)(\"stroke-linecap\", ctx_r11.svg.path.strokeLinecap)(\"fill\", ctx_r11.svg.path.fill);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, CircleProgressComponent__svg_svg_0__svg_ng_container_6__svg_path_1_Template, 1, 5, \"path\", 2);\n    ɵngcc0.ɵɵtemplate(2, CircleProgressComponent__svg_svg_0__svg_ng_container_6__svg_path_2_Template, 1, 5, \"path\", 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r5.options.outerStrokeGradient);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.options.outerStrokeGradient);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_1__svg_tspan_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"tspan\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const tspan_r16 = ctx.$implicit;\n    const ctx_r15 = ɵngcc0.ɵɵnextContext(4);\n    ɵngcc0.ɵɵattribute(\"x\", ctx_r15.svg.title.x)(\"y\", ctx_r15.svg.title.y)(\"dy\", tspan_r16.dy)(\"font-size\", ctx_r15.svg.title.fontSize)(\"font-weight\", ctx_r15.svg.title.fontWeight)(\"fill\", ctx_r15.svg.title.color);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(tspan_r16.span);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_1__svg_tspan_1_Template, 2, 7, \"tspan\", 8);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r12.svg.title.tspans);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_text_7__svg_tspan_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"tspan\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵattribute(\"font-size\", ctx_r13.svg.units.fontSize)(\"font-weight\", ctx_r13.svg.units.fontWeight)(\"fill\", ctx_r13.svg.units.color);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r13.svg.units.text);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_3__svg_tspan_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"tspan\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const tspan_r18 = ctx.$implicit;\n    const ctx_r17 = ɵngcc0.ɵɵnextContext(4);\n    ɵngcc0.ɵɵattribute(\"x\", ctx_r17.svg.subtitle.x)(\"y\", ctx_r17.svg.subtitle.y)(\"dy\", tspan_r18.dy)(\"font-size\", ctx_r17.svg.subtitle.fontSize)(\"font-weight\", ctx_r17.svg.subtitle.fontWeight)(\"fill\", ctx_r17.svg.subtitle.color);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(tspan_r18.span);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_3__svg_tspan_1_Template, 2, 7, \"tspan\", 8);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r14.svg.subtitle.tspans);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_text_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"text\", 7);\n    ɵngcc0.ɵɵtemplate(1, CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_1_Template, 2, 1, \"ng-container\", 2);\n    ɵngcc0.ɵɵtemplate(2, CircleProgressComponent__svg_svg_0__svg_text_7__svg_tspan_2_Template, 2, 4, \"tspan\", 2);\n    ɵngcc0.ɵɵtemplate(3, CircleProgressComponent__svg_svg_0__svg_text_7__svg_ng_container_3_Template, 2, 1, \"ng-container\", 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"x\", ctx_r6.svg.circle.cx)(\"y\", ctx_r6.svg.circle.cy)(\"text-anchor\", ctx_r6.svg.title.textAnchor);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r6.options.showTitle);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r6.options.showUnits);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r6.options.showSubtitle);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0__svg_image_8_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"image\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"height\", ctx_r7.svg.image.height)(\"width\", ctx_r7.svg.image.width)(\"href\", ctx_r7.svg.image.src, null, \"xlink\")(\"x\", ctx_r7.svg.image.x)(\"y\", ctx_r7.svg.image.y);\n  }\n}\n\nfunction CircleProgressComponent__svg_svg_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 1);\n    ɵngcc0.ɵɵlistener(\"click\", function CircleProgressComponent__svg_svg_0_Template__svg_svg_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r20);\n      const ctx_r19 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r19.emitClickEvent($event));\n    });\n    ɵngcc0.ɵɵelementStart(1, \"defs\");\n    ɵngcc0.ɵɵtemplate(2, CircleProgressComponent__svg_svg_0__svg_linearGradient_2_Template, 3, 5, \"linearGradient\", 2);\n    ɵngcc0.ɵɵtemplate(3, CircleProgressComponent__svg_svg_0__svg_radialGradient_3_Template, 3, 5, \"radialGradient\", 2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(4, CircleProgressComponent__svg_svg_0__svg_ng_container_4_Template, 3, 2, \"ng-container\", 2);\n    ɵngcc0.ɵɵtemplate(5, CircleProgressComponent__svg_svg_0__svg_circle_5_Template, 1, 6, \"circle\", 2);\n    ɵngcc0.ɵɵtemplate(6, CircleProgressComponent__svg_svg_0__svg_ng_container_6_Template, 3, 2, \"ng-container\", 2);\n    ɵngcc0.ɵɵtemplate(7, CircleProgressComponent__svg_svg_0__svg_text_7_Template, 4, 6, \"text\", 3);\n    ɵngcc0.ɵɵtemplate(8, CircleProgressComponent__svg_svg_0__svg_image_8_Template, 1, 5, \"image\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"viewBox\", ctx_r0.svg.viewBox)(\"height\", ctx_r0.svg.height)(\"width\", ctx_r0.svg.width)(\"class\", ctx_r0.options.class);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.options.outerStrokeGradient);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.options.backgroundGradient);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.options.showBackground);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.options.showInnerStroke);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", +ctx_r0.options.percent !== 0 || ctx_r0.options.showZeroOuterStroke);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.options.showImage && (ctx_r0.options.showTitle || ctx_r0.options.showUnits || ctx_r0.options.showSubtitle));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.options.showImage);\n  }\n}\n\nclass CircleProgressOptions {\n  constructor() {\n    this.class = '';\n    this.backgroundGradient = false;\n    this.backgroundColor = 'transparent';\n    this.backgroundGradientStopColor = 'transparent';\n    this.backgroundOpacity = 1;\n    this.backgroundStroke = 'transparent';\n    this.backgroundStrokeWidth = 0;\n    this.backgroundPadding = 5;\n    this.percent = 0;\n    this.radius = 90;\n    this.space = 4;\n    this.toFixed = 0;\n    this.maxPercent = 1000;\n    this.renderOnClick = true;\n    this.units = '%';\n    this.unitsFontSize = '10';\n    this.unitsFontWeight = 'normal';\n    this.unitsColor = '#444444';\n    this.outerStrokeGradient = false;\n    this.outerStrokeWidth = 8;\n    this.outerStrokeColor = '#78C000';\n    this.outerStrokeGradientStopColor = 'transparent';\n    this.outerStrokeLinecap = 'round';\n    this.innerStrokeColor = '#C7E596';\n    this.innerStrokeWidth = 4;\n    this.titleFormat = undefined;\n    this.title = 'auto';\n    this.titleColor = '#444444';\n    this.titleFontSize = '20';\n    this.titleFontWeight = 'normal';\n    this.subtitleFormat = undefined;\n    this.subtitle = 'progress';\n    this.subtitleColor = '#A9A9A9';\n    this.subtitleFontSize = '10';\n    this.subtitleFontWeight = 'normal';\n    this.imageSrc = undefined;\n    this.imageHeight = undefined;\n    this.imageWidth = undefined;\n    this.animation = true;\n    this.animateTitle = true;\n    this.animateSubtitle = false;\n    this.animationDuration = 500;\n    this.showTitle = true;\n    this.showSubtitle = true;\n    this.showUnits = true;\n    this.showImage = false;\n    this.showBackground = true;\n    this.showInnerStroke = true;\n    this.clockwise = true;\n    this.responsive = false;\n    this.startFromZero = true;\n    this.showZeroOuterStroke = true;\n    this.lazy = false;\n  }\n\n}\n/** @dynamic Prevent compiling error when using type `Document` https://github.com/angular/angular/issues/20351 */\n\n\nlet CircleProgressComponent = /*#__PURE__*/(() => {\n  class CircleProgressComponent {\n    constructor(defaultOptions, elRef, document) {\n      this.elRef = elRef;\n      this.document = document;\n      this.onClick = new EventEmitter(); // <svg> of component\n\n      this.svgElement = null; // whether <svg> is in viewport\n\n      this.isInViewport = false; // event for notifying viewport change caused by scrolling or resizing\n\n      this.onViewportChanged = new EventEmitter();\n      this._viewportChangedSubscriber = null;\n      this.options = new CircleProgressOptions();\n      this.defaultOptions = new CircleProgressOptions();\n      this._lastPercent = 0;\n      this._gradientUUID = null;\n\n      this.render = () => {\n        this.applyOptions();\n\n        if (this.options.lazy) {\n          // Draw svg if it doesn't exist\n          this.svgElement === null && this.draw(this._lastPercent); // Draw it only when it's in the viewport\n\n          if (this.isInViewport) {\n            // Draw it at the latest position when I am in.\n            if (this.options.animation && this.options.animationDuration > 0) {\n              this.animate(this._lastPercent, this.options.percent);\n            } else {\n              this.draw(this.options.percent);\n            }\n\n            this._lastPercent = this.options.percent;\n          }\n        } else {\n          if (this.options.animation && this.options.animationDuration > 0) {\n            this.animate(this._lastPercent, this.options.percent);\n          } else {\n            this.draw(this.options.percent);\n          }\n\n          this._lastPercent = this.options.percent;\n        }\n      };\n\n      this.polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {\n        let angleInRadius = angleInDegrees * Math.PI / 180;\n        let x = centerX + Math.sin(angleInRadius) * radius;\n        let y = centerY - Math.cos(angleInRadius) * radius;\n        return {\n          x: x,\n          y: y\n        };\n      };\n\n      this.draw = percent => {\n        // make percent reasonable\n        percent = percent === undefined ? this.options.percent : Math.abs(percent); // circle percent shouldn't be greater than 100%.\n\n        let circlePercent = percent > 100 ? 100 : percent; // determine box size\n\n        let boxSize = this.options.radius * 2 + this.options.outerStrokeWidth * 2;\n\n        if (this.options.showBackground) {\n          boxSize += this.options.backgroundStrokeWidth * 2 + this.max(0, this.options.backgroundPadding * 2);\n        } // the centre of the circle\n\n\n        let centre = {\n          x: boxSize / 2,\n          y: boxSize / 2\n        }; // the start point of the arc\n\n        let startPoint = {\n          x: centre.x,\n          y: centre.y - this.options.radius\n        }; // get the end point of the arc\n\n        let endPoint = this.polarToCartesian(centre.x, centre.y, this.options.radius, 360 * (this.options.clockwise ? circlePercent : 100 - circlePercent) / 100); // ####################\n        // We'll get an end point with the same [x, y] as the start point when percent is 100%, so move x a little bit.\n\n        if (circlePercent === 100) {\n          endPoint.x = endPoint.x + (this.options.clockwise ? -0.01 : +0.01);\n        } // largeArcFlag and sweepFlag\n\n\n        let largeArcFlag, sweepFlag;\n\n        if (circlePercent > 50) {\n          [largeArcFlag, sweepFlag] = this.options.clockwise ? [1, 1] : [1, 0];\n        } else {\n          [largeArcFlag, sweepFlag] = this.options.clockwise ? [0, 1] : [0, 0];\n        } // percent may not equal the actual percent\n\n\n        let titlePercent = this.options.animateTitle ? percent : this.options.percent;\n        let titleTextPercent = titlePercent > this.options.maxPercent ? `${this.options.maxPercent.toFixed(this.options.toFixed)}+` : titlePercent.toFixed(this.options.toFixed);\n        let subtitlePercent = this.options.animateSubtitle ? percent : this.options.percent; // get title object\n\n        let title = {\n          x: centre.x,\n          y: centre.y,\n          textAnchor: 'middle',\n          color: this.options.titleColor,\n          fontSize: this.options.titleFontSize,\n          fontWeight: this.options.titleFontWeight,\n          texts: [],\n          tspans: []\n        }; // from v0.9.9, both title and titleFormat(...) may be an array of string.\n\n        if (this.options.titleFormat !== undefined && this.options.titleFormat.constructor.name === 'Function') {\n          let formatted = this.options.titleFormat(titlePercent);\n\n          if (formatted instanceof Array) {\n            title.texts = [...formatted];\n          } else {\n            title.texts.push(formatted.toString());\n          }\n        } else {\n          if (this.options.title === 'auto') {\n            title.texts.push(titleTextPercent);\n          } else {\n            if (this.options.title instanceof Array) {\n              title.texts = [...this.options.title];\n            } else {\n              title.texts.push(this.options.title.toString());\n            }\n          }\n        } // get subtitle object\n\n\n        let subtitle = {\n          x: centre.x,\n          y: centre.y,\n          textAnchor: 'middle',\n          color: this.options.subtitleColor,\n          fontSize: this.options.subtitleFontSize,\n          fontWeight: this.options.subtitleFontWeight,\n          texts: [],\n          tspans: []\n        }; // from v0.9.9, both subtitle and subtitleFormat(...) may be an array of string.\n\n        if (this.options.subtitleFormat !== undefined && this.options.subtitleFormat.constructor.name === 'Function') {\n          let formatted = this.options.subtitleFormat(subtitlePercent);\n\n          if (formatted instanceof Array) {\n            subtitle.texts = [...formatted];\n          } else {\n            subtitle.texts.push(formatted.toString());\n          }\n        } else {\n          if (this.options.subtitle instanceof Array) {\n            subtitle.texts = [...this.options.subtitle];\n          } else {\n            subtitle.texts.push(this.options.subtitle.toString());\n          }\n        } // get units object\n\n\n        let units = {\n          text: `${this.options.units}`,\n          fontSize: this.options.unitsFontSize,\n          fontWeight: this.options.unitsFontWeight,\n          color: this.options.unitsColor\n        }; // get total count of text lines to be shown\n\n        let rowCount = 0,\n            rowNum = 1;\n        this.options.showTitle && (rowCount += title.texts.length);\n        this.options.showSubtitle && (rowCount += subtitle.texts.length); // calc dy for each tspan for title\n\n        if (this.options.showTitle) {\n          for (let span of title.texts) {\n            title.tspans.push({\n              span: span,\n              dy: this.getRelativeY(rowNum, rowCount)\n            });\n            rowNum++;\n          }\n        } // calc dy for each tspan for subtitle\n\n\n        if (this.options.showSubtitle) {\n          for (let span of subtitle.texts) {\n            subtitle.tspans.push({\n              span: span,\n              dy: this.getRelativeY(rowNum, rowCount)\n            });\n            rowNum++;\n          }\n        } // create ID for gradient element\n\n\n        if (null === this._gradientUUID) {\n          this._gradientUUID = this.uuid();\n        } // Bring it all together\n\n\n        this.svg = {\n          viewBox: `0 0 ${boxSize} ${boxSize}`,\n          // Set both width and height to '100%' if it's responsive\n          width: this.options.responsive ? '100%' : boxSize,\n          height: this.options.responsive ? '100%' : boxSize,\n          backgroundCircle: {\n            cx: centre.x,\n            cy: centre.y,\n            r: this.options.radius + this.options.outerStrokeWidth / 2 + this.options.backgroundPadding,\n            fill: this.options.backgroundColor,\n            fillOpacity: this.options.backgroundOpacity,\n            stroke: this.options.backgroundStroke,\n            strokeWidth: this.options.backgroundStrokeWidth\n          },\n          path: {\n            // A rx ry x-axis-rotation large-arc-flag sweep-flag x y (https://developer.mozilla.org/en/docs/Web/SVG/Tutorial/Paths#Arcs)\n            d: `M ${startPoint.x} ${startPoint.y}\n        A ${this.options.radius} ${this.options.radius} 0 ${largeArcFlag} ${sweepFlag} ${endPoint.x} ${endPoint.y}`,\n            stroke: this.options.outerStrokeColor,\n            strokeWidth: this.options.outerStrokeWidth,\n            strokeLinecap: this.options.outerStrokeLinecap,\n            fill: 'none'\n          },\n          circle: {\n            cx: centre.x,\n            cy: centre.y,\n            r: this.options.radius - this.options.space - this.options.outerStrokeWidth / 2 - this.options.innerStrokeWidth / 2,\n            fill: 'none',\n            stroke: this.options.innerStrokeColor,\n            strokeWidth: this.options.innerStrokeWidth\n          },\n          title: title,\n          units: units,\n          subtitle: subtitle,\n          image: {\n            x: centre.x - this.options.imageWidth / 2,\n            y: centre.y - this.options.imageHeight / 2,\n            src: this.options.imageSrc,\n            width: this.options.imageWidth,\n            height: this.options.imageHeight\n          },\n          outerLinearGradient: {\n            id: 'outer-linear-' + this._gradientUUID,\n            colorStop1: this.options.outerStrokeColor,\n            colorStop2: this.options.outerStrokeGradientStopColor === 'transparent' ? '#FFF' : this.options.outerStrokeGradientStopColor\n          },\n          radialGradient: {\n            id: 'radial-' + this._gradientUUID,\n            colorStop1: this.options.backgroundColor,\n            colorStop2: this.options.backgroundGradientStopColor === 'transparent' ? '#FFF' : this.options.backgroundGradientStopColor\n          }\n        };\n      };\n\n      this.getAnimationParameters = (previousPercent, currentPercent) => {\n        const MIN_INTERVAL = 10;\n        let times, step, interval;\n        let fromPercent = this.options.startFromZero ? 0 : previousPercent < 0 ? 0 : previousPercent;\n        let toPercent = currentPercent < 0 ? 0 : this.min(currentPercent, this.options.maxPercent);\n        let delta = Math.abs(Math.round(toPercent - fromPercent));\n\n        if (delta >= 100) {\n          // we will finish animation in 100 times\n          times = 100;\n\n          if (!this.options.animateTitle && !this.options.animateSubtitle) {\n            step = 1;\n          } else {\n            // show title or subtitle animation even if the arc is full, we also need to finish it in 100 times.\n            step = Math.round(delta / times);\n          }\n        } else {\n          // we will finish in as many times as the number of percent.\n          times = delta;\n          step = 1;\n        } // Get the interval of timer\n\n\n        interval = Math.round(this.options.animationDuration / times); // Readjust all values if the interval of timer is extremely small.\n\n        if (interval < MIN_INTERVAL) {\n          interval = MIN_INTERVAL;\n          times = this.options.animationDuration / interval;\n\n          if (!this.options.animateTitle && !this.options.animateSubtitle && delta > 100) {\n            step = Math.round(100 / times);\n          } else {\n            step = Math.round(delta / times);\n          }\n        } // step must be greater than 0.\n\n\n        if (step < 1) {\n          step = 1;\n        }\n\n        return {\n          times: times,\n          step: step,\n          interval: interval\n        };\n      };\n\n      this.animate = (previousPercent, currentPercent) => {\n        if (this._timerSubscription && !this._timerSubscription.closed) {\n          this._timerSubscription.unsubscribe();\n        }\n\n        let fromPercent = this.options.startFromZero ? 0 : previousPercent;\n        let toPercent = currentPercent;\n        let {\n          step: step,\n          interval: interval\n        } = this.getAnimationParameters(fromPercent, toPercent);\n        let count = fromPercent;\n\n        if (fromPercent < toPercent) {\n          this._timerSubscription = timer(0, interval).subscribe(() => {\n            count += step;\n\n            if (count <= toPercent) {\n              if (!this.options.animateTitle && !this.options.animateSubtitle && count >= 100) {\n                this.draw(toPercent);\n\n                this._timerSubscription.unsubscribe();\n              } else {\n                this.draw(count);\n              }\n            } else {\n              this.draw(toPercent);\n\n              this._timerSubscription.unsubscribe();\n            }\n          });\n        } else {\n          this._timerSubscription = timer(0, interval).subscribe(() => {\n            count -= step;\n\n            if (count >= toPercent) {\n              if (!this.options.animateTitle && !this.options.animateSubtitle && toPercent >= 100) {\n                this.draw(toPercent);\n\n                this._timerSubscription.unsubscribe();\n              } else {\n                this.draw(count);\n              }\n            } else {\n              this.draw(toPercent);\n\n              this._timerSubscription.unsubscribe();\n            }\n          });\n        }\n      };\n\n      this.emitClickEvent = event => {\n        if (this.options.renderOnClick) {\n          this.animate(0, this.options.percent);\n        }\n\n        this.onClick.emit(event);\n      };\n\n      this.applyOptions = () => {\n        // the options of <circle-progress> may change already\n        for (let name of Object.keys(this.options)) {\n          if (this.hasOwnProperty(name) && this[name] !== undefined) {\n            this.options[name] = this[name];\n          } else if (this.templateOptions && this.templateOptions[name] !== undefined) {\n            this.options[name] = this.templateOptions[name];\n          }\n        } // make sure key options valid\n\n\n        this.options.radius = Math.abs(+this.options.radius);\n        this.options.space = +this.options.space;\n        this.options.percent = +this.options.percent > 0 ? +this.options.percent : 0;\n        this.options.maxPercent = Math.abs(+this.options.maxPercent);\n        this.options.animationDuration = Math.abs(this.options.animationDuration);\n        this.options.outerStrokeWidth = Math.abs(+this.options.outerStrokeWidth);\n        this.options.innerStrokeWidth = Math.abs(+this.options.innerStrokeWidth);\n        this.options.backgroundPadding = +this.options.backgroundPadding;\n      };\n\n      this.getRelativeY = (rowNum, rowCount) => {\n        // why '-0.18em'? It's a magic number when property 'alignment-baseline' equals 'baseline'. :)\n        let initialOffset = -0.18,\n            offset = 1;\n        return (initialOffset + offset * (rowNum - rowCount / 2)).toFixed(2) + 'em';\n      };\n\n      this.min = (a, b) => {\n        return a < b ? a : b;\n      };\n\n      this.max = (a, b) => {\n        return a > b ? a : b;\n      };\n\n      this.uuid = () => {\n        // https://www.w3resource.com/javascript-exercises/javascript-math-exercise-23.php\n        var dt = new Date().getTime();\n        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n          var r = (dt + Math.random() * 16) % 16 | 0;\n          dt = Math.floor(dt / 16);\n          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n        });\n        return uuid;\n      };\n\n      this.findSvgElement = function () {\n        if (this.svgElement === null) {\n          let tags = this.elRef.nativeElement.getElementsByTagName('svg');\n\n          if (tags.length > 0) {\n            this.svgElement = tags[0];\n          }\n        }\n      };\n\n      this.checkViewport = () => {\n        this.findSvgElement();\n        let previousValue = this.isInViewport;\n        this.isInViewport = this.isElementInViewport(this.svgElement);\n\n        if (previousValue !== this.isInViewport) {\n          this.onViewportChanged.emit({\n            oldValue: previousValue,\n            newValue: this.isInViewport\n          });\n        }\n      };\n\n      this.onScroll = event => {\n        this.checkViewport();\n      };\n\n      this.loadEventsForLazyMode = () => {\n        if (this.options.lazy) {\n          this.document.addEventListener('scroll', this.onScroll, true);\n          this.window.addEventListener('resize', this.onScroll, true);\n\n          if (this._viewportChangedSubscriber === null) {\n            this._viewportChangedSubscriber = this.onViewportChanged.subscribe(({\n              oldValue,\n              newValue\n            }) => {\n              newValue ? this.render() : null;\n            });\n          } // svgElement must be created in DOM before being checked.\n          // Is there a better way to check the existence of svgElemnt?\n\n\n          let _timer = timer(0, 50).subscribe(() => {\n            this.svgElement === null ? this.checkViewport() : _timer.unsubscribe();\n          });\n        }\n      };\n\n      this.unloadEventsForLazyMode = () => {\n        // Remove event listeners\n        this.document.removeEventListener('scroll', this.onScroll, true);\n        this.window.removeEventListener('resize', this.onScroll, true); // Unsubscribe onViewportChanged\n\n        if (this._viewportChangedSubscriber !== null) {\n          this._viewportChangedSubscriber.unsubscribe();\n\n          this._viewportChangedSubscriber = null;\n        }\n      };\n\n      this.document = document;\n      this.window = this.document.defaultView;\n      Object.assign(this.options, defaultOptions);\n      Object.assign(this.defaultOptions, defaultOptions);\n    }\n\n    isDrawing() {\n      return this._timerSubscription && !this._timerSubscription.closed;\n    }\n\n    isElementInViewport(el) {\n      // Return false if el has not been created in page.\n      if (el === null || el === undefined) return false; // Check if the element is out of view due to a container scrolling\n\n      let rect = el.getBoundingClientRect(),\n          parent = el.parentNode,\n          parentRect;\n\n      do {\n        parentRect = parent.getBoundingClientRect();\n        if (rect.top >= parentRect.bottom) return false;\n        if (rect.bottom <= parentRect.top) return false;\n        if (rect.left >= parentRect.right) return false;\n        if (rect.right <= parentRect.left) return false;\n        parent = parent.parentNode;\n      } while (parent != this.document.body); // Check its within the document viewport\n\n\n      if (rect.top >= (this.window.innerHeight || this.document.documentElement.clientHeight)) return false;\n      if (rect.bottom <= 0) return false;\n      if (rect.left >= (this.window.innerWidth || this.document.documentElement.clientWidth)) return false;\n      if (rect.right <= 0) return false;\n      return true;\n    }\n\n    ngOnInit() {\n      this.loadEventsForLazyMode();\n    }\n\n    ngOnDestroy() {\n      this.unloadEventsForLazyMode();\n    }\n\n    ngOnChanges(changes) {\n      this.render();\n\n      if ('lazy' in changes) {\n        changes.lazy.currentValue ? this.loadEventsForLazyMode() : this.unloadEventsForLazyMode();\n      }\n    }\n\n  }\n\n  CircleProgressComponent.ɵfac = function CircleProgressComponent_Factory(t) {\n    return new (t || CircleProgressComponent)(ɵngcc0.ɵɵdirectiveInject(CircleProgressOptions), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  CircleProgressComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CircleProgressComponent,\n    selectors: [[\"circle-progress\"]],\n    inputs: {\n      name: \"name\",\n      class: \"class\",\n      backgroundGradient: \"backgroundGradient\",\n      backgroundColor: \"backgroundColor\",\n      backgroundGradientStopColor: \"backgroundGradientStopColor\",\n      backgroundOpacity: \"backgroundOpacity\",\n      backgroundStroke: \"backgroundStroke\",\n      backgroundStrokeWidth: \"backgroundStrokeWidth\",\n      backgroundPadding: \"backgroundPadding\",\n      radius: \"radius\",\n      space: \"space\",\n      percent: \"percent\",\n      toFixed: \"toFixed\",\n      maxPercent: \"maxPercent\",\n      renderOnClick: \"renderOnClick\",\n      units: \"units\",\n      unitsFontSize: \"unitsFontSize\",\n      unitsFontWeight: \"unitsFontWeight\",\n      unitsColor: \"unitsColor\",\n      outerStrokeGradient: \"outerStrokeGradient\",\n      outerStrokeWidth: \"outerStrokeWidth\",\n      outerStrokeColor: \"outerStrokeColor\",\n      outerStrokeGradientStopColor: \"outerStrokeGradientStopColor\",\n      outerStrokeLinecap: \"outerStrokeLinecap\",\n      innerStrokeColor: \"innerStrokeColor\",\n      innerStrokeWidth: \"innerStrokeWidth\",\n      titleFormat: \"titleFormat\",\n      title: \"title\",\n      titleColor: \"titleColor\",\n      titleFontSize: \"titleFontSize\",\n      titleFontWeight: \"titleFontWeight\",\n      subtitleFormat: \"subtitleFormat\",\n      subtitle: \"subtitle\",\n      subtitleColor: \"subtitleColor\",\n      subtitleFontSize: \"subtitleFontSize\",\n      subtitleFontWeight: \"subtitleFontWeight\",\n      imageSrc: \"imageSrc\",\n      imageHeight: \"imageHeight\",\n      imageWidth: \"imageWidth\",\n      animation: \"animation\",\n      animateTitle: \"animateTitle\",\n      animateSubtitle: \"animateSubtitle\",\n      animationDuration: \"animationDuration\",\n      showTitle: \"showTitle\",\n      showSubtitle: \"showSubtitle\",\n      showUnits: \"showUnits\",\n      showImage: \"showImage\",\n      showBackground: \"showBackground\",\n      showInnerStroke: \"showInnerStroke\",\n      clockwise: \"clockwise\",\n      responsive: \"responsive\",\n      startFromZero: \"startFromZero\",\n      showZeroOuterStroke: \"showZeroOuterStroke\",\n      lazy: \"lazy\",\n      templateOptions: [\"options\", \"templateOptions\"]\n    },\n    outputs: {\n      onClick: \"onClick\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[\"xmlns\", \"http://www.w3.org/2000/svg\", \"preserveAspectRatio\", \"xMidYMid meet\", 3, \"click\", 4, \"ngIf\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", \"preserveAspectRatio\", \"xMidYMid meet\", 3, \"click\"], [4, \"ngIf\"], [\"alignment-baseline\", \"baseline\", 4, \"ngIf\"], [\"preserveAspectRatio\", \"none\", 4, \"ngIf\"], [\"offset\", \"5%\"], [\"offset\", \"95%\"], [\"alignment-baseline\", \"baseline\"], [4, \"ngFor\", \"ngForOf\"], [\"preserveAspectRatio\", \"none\"]],\n    template: function CircleProgressComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, CircleProgressComponent__svg_svg_0_Template, 9, 11, \"svg\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.svg);\n      }\n    },\n    dependencies: [ɵngcc1.NgForOf, ɵngcc1.NgIf],\n    encapsulation: 2\n  });\n  return CircleProgressComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgCircleProgressModule = /*#__PURE__*/(() => {\n  class NgCircleProgressModule {\n    static forRoot(options = {}) {\n      return {\n        ngModule: NgCircleProgressModule,\n        providers: [{\n          provide: CircleProgressOptions,\n          useValue: options\n        }]\n      };\n    }\n\n  }\n\n  NgCircleProgressModule.ɵfac = function NgCircleProgressModule_Factory(t) {\n    return new (t || NgCircleProgressModule)();\n  };\n\n  NgCircleProgressModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgCircleProgressModule\n  });\n  NgCircleProgressModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return NgCircleProgressModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgCircleProgressModule, {\n    declarations: function () {\n      return [CircleProgressComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [CircleProgressComponent];\n    }\n  });\n})();\n/*\r\n * Public API Surface of ng-circle-progress\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { CircleProgressComponent, CircleProgressOptions, NgCircleProgressModule }; //# sourceMappingURL=ng-circle-progress.js.map","map":null,"metadata":{},"sourceType":"module"}